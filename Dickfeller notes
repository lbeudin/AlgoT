
Research on Times serie :
Time series are stationary if they do not have trend or seasonal effects. 
Summary statistics calculated on the time series are consistent over time, like the mean or the variance of the observations.
Observations from a non-stationary time series show seasonal effects, trends, and other structures that depend on the time index.


    Stationary Process: A process that generates a stationary series of observations.
    Stationary Model: A model that describes a stationary series of observations.
    Trend Stationary: A time series that does not exhibit a trend.
    Seasonal Stationary: A time series that does not exhibit seasonality.
    Strictly Stationary: A mathematical definition of a stationary process, specifically that the joint distribution of observations is invariant to time shift.

summary  statistic test:
You can split your time series into two (or more) partitions and compare the mean and variance of each group.
If they differ and the difference is statistically significant, the time series is likely non-stationary.

Augmented Dickey-Fuller test

Statistical tests make strong assumptions about your data. They can only be used to inform the degree to which a null hypothesis can be rejected or fail to be reject. 
The result must be interpreted for a given problem to be meaningful.

source :https://machinelearningmastery.com/time-series-data-stationary-python/
	
from pandas import read_csv
from statsmodels.tsa.stattools import adfuller
series = read_csv('daily-total-female-births.csv', header=0, index_col=0, squeeze=True)
for i in range(0,4):
	#create object
	dict_trade=
	Dickfeller_statTest(dict_trade)
	
def Dickfeller_statTest(series):
	X = series.values
	result = adfuller(X)
	print('ADF Statistic: %f' % result[0])
	
https://www.survivrelondres.co.uk/wp-content/uploads/2018/06/Fonctions-de-Bloomberg.pdf
	print('p-value: %f' % result[1])
	print('Critical Values:')
	for key, value in result[4].items():
		print('\t%s: %.3f' % (key, value))

https://www.survivrelondres.co.uk/wp-content/uploads/2018/06/Fonctions-de-Bloomberg.pdf




from itertools import combinations
from itertools import permutations
from itertools import product
from collections import Counter

        
        
li =[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17]
test = product(li,repeat=8)

def fact(n):
    fac =1
    while(n>1):
        fac=fac*n
        n=n-1
    return fac
    

compteur =0
for i in test:
    if sum(i)==100:
        compteur =compteur +1
        '''
        tes = Counter(i)
        denom=1
        for j in tes:
            #print(tes[j])
            denom = fact(test[j])*denom
        compteur = compteur +fact(8)/denom'''
        
print(compteur)
